import "./chunk-TWLJ45QX.js";

// node_modules/quill-image-drop-and-paste/dist/quill-image-drop-and-paste.esm.js
var utils = {
  generateFilename() {
    return btoa(String(Math.random() * 1e6) + String(+new Date())).replace("=", "");
  },
  urlIsImage(url, abortTimeout = 3e3) {
    if (!this.validURL(url)) {
      return Promise.reject(false);
    }
    if (/\.(jpeg|jpg|gif|png|webp|tiff|bmp)$/.test(url)) {
      return Promise.resolve(true);
    }
    return new Promise((resolve, reject) => {
      let timer = void 0;
      const img = new Image();
      img.onerror = img.onabort = () => {
        clearTimeout(timer);
        reject(false);
      };
      img.onload = () => {
        clearTimeout(timer);
        resolve(true);
      };
      timer = setTimeout(() => {
        img.src = "//!/an/invalid.jpg";
        reject(false);
      }, abortTimeout);
      img.src = url;
    });
  },
  validURL(str) {
    try {
      return Boolean(new URL(str));
    } catch (e) {
      return false;
    }
  },
  isRichText(clipboardDataItems) {
    let isHtml = false;
    Array.prototype.forEach.call(clipboardDataItems, (item) => {
      if (item.type.match(/^text\/html$/i)) {
        isHtml = true;
      }
    });
    return isHtml;
  },
  resolveDataUrl(dataUrl, type) {
    let str = "";
    if (typeof dataUrl === "string") {
      str = dataUrl;
    } else if (dataUrl instanceof ArrayBuffer) {
      str = this.arrayBufferToBase64Url(dataUrl, type);
    }
    return str;
  },
  binaryStringToArrayBuffer(binary) {
    const len = binary.length;
    const buffer = new ArrayBuffer(len);
    const arr = new Uint8Array(buffer);
    let i = -1;
    while (++i < len)
      arr[i] = binary.charCodeAt(i);
    return buffer;
  },
  arrayBufferToBase64Url(arrayBuffer, type) {
    return `data:${type};base64,` + btoa(new Uint8Array(arrayBuffer).reduce((acc, byte) => acc + String.fromCharCode(byte), ""));
  },
  copyText(content, target = document.body) {
    const element = document.createElement("textarea");
    const previouslyFocusedElement = document.activeElement;
    element.value = content;
    element.setAttribute("readonly", "");
    element.style.position = "absolute";
    element.style.left = "-9999px";
    element.style.fontSize = "12pt";
    const selection = document.getSelection();
    let originalRange = false;
    if (selection && selection.rangeCount > 0) {
      originalRange = selection.getRangeAt(0);
    }
    target.append(element);
    element.select();
    element.selectionStart = 0;
    element.selectionEnd = content.length;
    let isSuccess = false;
    try {
      isSuccess = document.execCommand("copy");
    } catch (_a) {
    }
    element.remove();
    if (selection && originalRange) {
      selection.removeAllRanges();
      selection.addRange(originalRange);
    }
    if (previouslyFocusedElement) {
      previouslyFocusedElement.focus();
    }
    return isSuccess;
  },
  isType(target, type) {
    return Object.prototype.toString.call(target) === `[object ${type}]`;
  }
};
var QuillImageData = class {
  constructor(dataUrl, type, name) {
    this.dataUrl = dataUrl;
    this.type = type;
    this.name = name || "";
  }
};
var ImageData = class extends QuillImageData {
  constructor(dataUrl, type, name) {
    super(dataUrl, type, name);
    this.dataUrl = dataUrl;
    this.type = type;
    this.name = name || `${utils.generateFilename()}.${this.getSuffix()}`;
  }
  minify(option) {
    return new Promise((resolve, reject) => {
      const maxWidth = option.maxWidth || 800;
      const maxHeight = option.maxHeight || 800;
      const quality = option.quality || 0.8;
      if (!this.dataUrl) {
        return reject({
          message: "[error] QuillImageDropAndPaste: Fail to minify the image, dataUrl should not be empty."
        });
      }
      const image = new Image();
      image.onload = () => {
        const width = image.width;
        const height = image.height;
        if (width > height) {
          if (width > maxWidth) {
            image.height = height * maxWidth / width;
            image.width = maxWidth;
          }
        } else {
          if (height > maxHeight) {
            image.width = width * maxHeight / height;
            image.height = maxHeight;
          }
        }
        const canvas = document.createElement("canvas");
        canvas.width = image.width;
        canvas.height = image.height;
        const ctx = canvas.getContext("2d");
        if (ctx) {
          ctx.drawImage(image, 0, 0, image.width, image.height);
          const canvasType = this.type || "image/png";
          const canvasDataUrl = canvas.toDataURL(canvasType, quality);
          resolve(new ImageData(canvasDataUrl, canvasType, this.name));
        } else {
          reject({
            message: "[error] QuillImageDropAndPaste: Fail to minify the image, create canvas context failure."
          });
        }
      };
      image.src = utils.resolveDataUrl(this.dataUrl, this.type);
    });
  }
  toFile(filename) {
    filename = filename || this.name;
    if (!window.File) {
      console.error("[error] QuillImageDropAndPaste: Your browser didnot support File API.");
      return null;
    }
    return new File([this.toBlob()], filename, { type: this.type });
  }
  toBlob() {
    const base64 = utils.resolveDataUrl(this.dataUrl, this.type).replace(/^[^,]+,/, "");
    const buff = utils.binaryStringToArrayBuffer(atob(base64));
    return this.createBlob([buff], { type: this.type });
  }
  createBlob(parts, properties) {
    if (!properties)
      properties = {};
    if (typeof properties === "string")
      properties = { type: properties };
    try {
      return new Blob(parts, properties);
    } catch (e) {
      if (e.name !== "TypeError")
        throw e;
      const Builder = "BlobBuilder" in window ? window.BlobBuilder : "MSBlobBuilder" in window ? window.MSBlobBuilder : "MozBlobBuilder" in window ? window.MozBlobBuilder : window.WebKitBlobBuilder;
      const builder = new Builder();
      for (let i = 0; i < parts.length; i++)
        builder.append(parts[i]);
      return builder.getBlob(properties.type);
    }
  }
  getSuffix() {
    const matched = this.type.match(/^image\/(\w+)$/);
    const suffix = matched ? matched[1] : "png";
    return suffix;
  }
};
var QuillImageDropAndPaste = class {
  constructor(quill, option) {
    this.quill = quill;
    this.option = option;
  }
};
var ImageDropAndPaste = class extends QuillImageDropAndPaste {
  constructor(quill, option) {
    super(quill, option);
    this.quill = quill;
    this.option = option;
    this.handleDrop = this.handleDrop.bind(this);
    this.handlePaste = this.handlePaste.bind(this);
    this.insert = this.insert.bind(this);
    this.quill.root.addEventListener("drop", this.handleDrop, false);
    this.quill.root.addEventListener("paste", this.handlePaste, false);
  }
  handleDrop(e) {
    if (e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files.length) {
      e.preventDefault();
      if (document.caretRangeFromPoint) {
        const selection = document.getSelection();
        const range = document.caretRangeFromPoint(e.clientX, e.clientY);
        if (selection && range) {
          selection.setBaseAndExtent(range.startContainer, range.startOffset, range.startContainer, range.startOffset);
        }
      }
      this.readFiles(e.dataTransfer.files, (dataUrl, type = "image/png", name) => {
        if (typeof this.option.handler === "function") {
          this.option.handler.call(this, dataUrl, type, new ImageData(dataUrl, type, name));
        } else {
          this.insert.call(this, utils.resolveDataUrl(dataUrl, type), type);
        }
      }, e);
    }
  }
  handlePaste(e) {
    if (e.clipboardData && e.clipboardData.items && e.clipboardData.items.length) {
      if (utils.isRichText(e.clipboardData.items))
        return;
      this.readFiles(e.clipboardData.items, (dataUrl, type = "image/png") => {
        if (typeof this.option.handler === "function") {
          this.option.handler.call(this, dataUrl, type, new ImageData(dataUrl, type));
        } else {
          this.insert(utils.resolveDataUrl(dataUrl, type), "image");
        }
      }, e);
    }
  }
  readFiles(files, callback, e) {
    Array.prototype.forEach.call(files, (file) => {
      if (utils.isType(file, "DataTransferItem")) {
        this.handleDataTransfer(file, callback, e);
      } else if (file instanceof File) {
        this.handleDroppedFile(file, callback, e);
      }
    });
  }
  handleDataTransfer(file, callback, e) {
    const that = this;
    const { type } = file;
    if (type.match(/^image\/(gif|jpe?g|a?png|svg|webp|bmp)/i)) {
      e.preventDefault();
      const reader = new FileReader();
      reader.onload = (e2) => {
        if (e2.target && e2.target.result) {
          callback(e2.target.result, type);
        }
      };
      const blob = file.getAsFile ? file.getAsFile() : file;
      if (blob instanceof Blob)
        reader.readAsDataURL(blob);
    } else if (type.match(/^text\/plain$/i)) {
      file.getAsString((s) => {
        const i = this.getIndex();
        utils.urlIsImage(s).then(() => {
          const j = this.getIndex();
          this.quill.deleteText(i, j - i, "user");
          that.insert(s, "image");
        }).catch(() => {
        });
      });
    }
  }
  handleDroppedFile(file, callback, e) {
    const { type, name = "" } = file;
    if (type.match(/^image\/(gif|jpe?g|a?png|svg|webp|bmp)/i)) {
      e.preventDefault();
      const reader = new FileReader();
      reader.onload = (e2) => {
        if (e2.target && e2.target.result) {
          callback(e2.target.result, type, name);
        }
      };
      reader.readAsDataURL(file);
    }
  }
  insert(content, type) {
    const index = this.getIndex();
    let _index;
    if (type === "image") {
      _index = index + 1;
      this.quill.insertEmbed(index, type, content, "user");
    } else if (type === "text") {
      _index = index + content.length;
      this.quill.insertText(index, content, "user");
    }
    setTimeout(() => {
      this.quill.setSelection(_index);
    });
  }
  getIndex() {
    let index = (this.quill.getSelection(true) || {}).index;
    if (index === void 0 || index < 0)
      index = this.quill.getLength();
    return index;
  }
};
ImageDropAndPaste.ImageData = ImageData;
window.QuillImageDropAndPaste = ImageDropAndPaste;
if ("Quill" in window) {
  window.Quill.register("modules/imageDropAndPaste", ImageDropAndPaste);
}

// dep:quill-image-drop-and-paste
var quill_image_drop_and_paste_default = ImageDropAndPaste;
export {
  ImageData,
  quill_image_drop_and_paste_default as default
};
//# sourceMappingURL=quill-image-drop-and-paste.js.map
