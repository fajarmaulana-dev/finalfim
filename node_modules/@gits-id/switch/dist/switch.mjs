import { unref as d, computed as D, onMounted as dt, provide as ft, isRef as _e, watch as z, getCurrentInstance as ke, onBeforeUnmount as vt, defineComponent as Ce, toRef as re, resolveDynamicComponent as Ke, h as Be, inject as mt, ref as X, reactive as Qe, onUnmounted as gt, nextTick as he, warn as yt, watchEffect as Dt, markRaw as Ut, toRefs as Lt, openBlock as Re, createElementBlock as et, normalizeClass as ge, createVNode as tt, withCtx as De, createBlock as xt, createTextVNode as $t, toDisplayString as nt, createCommentVNode as rt, createElementVNode as Gt } from "vue";
import { SwitchGroup as zt, SwitchLabel as Ht, Switch as Kt } from "@headlessui/vue";
function Qt() {
  return ht().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function ht() {
  return typeof navigator < "u" && typeof window < "u" ? window : typeof global < "u" ? global : {};
}
const Wt = typeof Proxy == "function", qt = "devtools-plugin:setup", Jt = "plugin:settings:set";
let ye, Ge;
function Yt() {
  var e;
  return ye !== void 0 || (typeof window < "u" && window.performance ? (ye = !0, Ge = window.performance) : typeof global < "u" && ((e = global.perf_hooks) === null || e === void 0 ? void 0 : e.performance) ? (ye = !0, Ge = global.perf_hooks.performance) : ye = !1), ye;
}
function Xt() {
  return Yt() ? Ge.now() : Date.now();
}
class Zt {
  constructor(t, n) {
    this.target = null, this.targetQueue = [], this.onQueue = [], this.plugin = t, this.hook = n;
    const i = {};
    if (t.settings)
      for (const l in t.settings) {
        const s = t.settings[l];
        i[l] = s.defaultValue;
      }
    const r = `__vue-devtools-plugin-settings__${t.id}`;
    let a = Object.assign({}, i);
    try {
      const l = localStorage.getItem(r), s = JSON.parse(l);
      Object.assign(a, s);
    } catch {
    }
    this.fallbacks = {
      getSettings() {
        return a;
      },
      setSettings(l) {
        try {
          localStorage.setItem(r, JSON.stringify(l));
        } catch {
        }
        a = l;
      },
      now() {
        return Xt();
      }
    }, n && n.on(Jt, (l, s) => {
      l === this.plugin.id && this.fallbacks.setSettings(s);
    }), this.proxiedOn = new Proxy({}, {
      get: (l, s) => this.target ? this.target.on[s] : (...o) => {
        this.onQueue.push({
          method: s,
          args: o
        });
      }
    }), this.proxiedTarget = new Proxy({}, {
      get: (l, s) => this.target ? this.target[s] : s === "on" ? this.proxiedOn : Object.keys(this.fallbacks).includes(s) ? (...o) => (this.targetQueue.push({
        method: s,
        args: o,
        resolve: () => {
        }
      }), this.fallbacks[s](...o)) : (...o) => new Promise((f) => {
        this.targetQueue.push({
          method: s,
          args: o,
          resolve: f
        });
      })
    });
  }
  async setRealTarget(t) {
    this.target = t;
    for (const n of this.onQueue)
      this.target.on[n.method](...n.args);
    for (const n of this.targetQueue)
      n.resolve(await this.target[n.method](...n.args));
  }
}
function en(e, t) {
  const n = e, i = ht(), r = Qt(), a = Wt && n.enableEarlyProxy;
  if (r && (i.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !a))
    r.emit(qt, e, t);
  else {
    const l = a ? new Zt(n, r) : null;
    (i.__VUE_DEVTOOLS_PLUGINS__ = i.__VUE_DEVTOOLS_PLUGINS__ || []).push({
      pluginDescriptor: n,
      setupFn: t,
      proxy: l
    }), l && t(l.proxiedTarget);
  }
}
/**
  * vee-validate v4.6.2
  * (c) 2022 Abdelrahman Awad
  * @license MIT
  */
function pe(e) {
  return typeof e == "function";
}
function Ae(e) {
  return e == null;
}
const oe = (e) => e !== null && !!e && typeof e == "object" && !Array.isArray(e);
function bt(e) {
  return Number(e) >= 0;
}
function tn(e) {
  const t = parseFloat(e);
  return isNaN(t) ? e : t;
}
const nn = {};
function rn(e) {
  return nn[e];
}
const ce = Symbol("vee-validate-form"), an = Symbol("vee-validate-field-instance"), Te = Symbol("Default empty value");
function ze(e) {
  return pe(e) && !!e.__locatorRef;
}
function we(e) {
  return !!e && pe(e.validate);
}
function Ve(e) {
  return e === "checkbox" || e === "radio";
}
function ln(e) {
  return oe(e) || Array.isArray(e);
}
function pt(e) {
  return Array.isArray(e) ? e.length === 0 : oe(e) && Object.keys(e).length === 0;
}
function Me(e) {
  return /^\[.+\]$/i.test(e);
}
function un(e) {
  return Vt(e) && e.multiple;
}
function Vt(e) {
  return e.tagName === "SELECT";
}
function on(e, t) {
  const n = ![!1, null, void 0, 0].includes(t.multiple) && !Number.isNaN(t.multiple);
  return e === "select" && "multiple" in t && n;
}
function sn(e, t) {
  return !on(e, t) && t.type !== "file" && !Ve(t.type);
}
function Ot(e) {
  return We(e) && e.target && "submit" in e.target;
}
function We(e) {
  return e ? !!(typeof Event < "u" && pe(Event) && e instanceof Event || e && e.srcElement) : !1;
}
function it(e, t) {
  return t in e && e[t] !== Te;
}
function qe(e) {
  return Me(e) ? e.replace(/\[|\]/gi, "") : e;
}
function N(e, t, n) {
  return e ? Me(t) ? e[qe(t)] : (t || "").split(/\.|\[(\d+)\]/).filter(Boolean).reduce((r, a) => ln(r) && a in r ? r[a] : n, e) : n;
}
function le(e, t, n) {
  if (Me(t)) {
    e[qe(t)] = n;
    return;
  }
  const i = t.split(/\.|\[(\d+)\]/).filter(Boolean);
  let r = e;
  for (let a = 0; a < i.length; a++) {
    if (a === i.length - 1) {
      r[i[a]] = n;
      return;
    }
    (!(i[a] in r) || Ae(r[i[a]])) && (r[i[a]] = bt(i[a + 1]) ? [] : {}), r = r[i[a]];
  }
}
function Ue(e, t) {
  if (Array.isArray(e) && bt(t)) {
    e.splice(Number(t), 1);
    return;
  }
  oe(e) && delete e[t];
}
function Le(e, t) {
  if (Me(t)) {
    delete e[qe(t)];
    return;
  }
  const n = t.split(/\.|\[(\d+)\]/).filter(Boolean);
  let i = e;
  for (let a = 0; a < n.length; a++) {
    if (a === n.length - 1) {
      Ue(i, n[a]);
      break;
    }
    if (!(n[a] in i) || Ae(i[n[a]]))
      break;
    i = i[n[a]];
  }
  const r = n.map((a, l) => N(e, n.slice(0, l).join(".")));
  for (let a = r.length - 1; a >= 0; a--)
    if (!!pt(r[a])) {
      if (a === 0) {
        Ue(e, n[0]);
        continue;
      }
      Ue(r[a - 1], n[a - 1]);
    }
}
function L(e) {
  return Object.keys(e);
}
function Ie(e, t = void 0) {
  const n = ke();
  return n?.provides[e] || mt(e, t);
}
function xe(e) {
  yt(`[vee-validate]: ${e}`);
}
function cn(e) {
  return Array.isArray(e) ? e[0] : e;
}
function He(e, t, n) {
  if (Array.isArray(e)) {
    const i = [...e], r = i.indexOf(t);
    return r >= 0 ? i.splice(r, 1) : i.push(t), i;
  }
  return e === t ? n : t;
}
function dn(e, t) {
  let n, i;
  return function(...r) {
    const a = this;
    return n || (n = !0, setTimeout(() => n = !1, t), i = e.apply(a, r)), i;
  };
}
function at(e, t = 0) {
  let n = null, i = [];
  return function(...r) {
    return n && window.clearTimeout(n), n = window.setTimeout(() => {
      const a = e(...r);
      i.forEach((l) => l(a)), i = [];
    }, t), new Promise((a) => i.push(a));
  };
}
function fn(e, t) {
  if (!!oe(t))
    return t.number ? tn(e) : e;
}
const Pe = (e, t, n) => t.slots.default ? typeof e == "string" || !e ? t.slots.default(n()) : {
  default: () => {
    var i, r;
    return (r = (i = t.slots).default) === null || r === void 0 ? void 0 : r.call(i, n());
  }
} : t.slots.default;
function $e(e) {
  if (St(e))
    return e._value;
}
function St(e) {
  return "_value" in e;
}
function Je(e) {
  if (!We(e))
    return e;
  const t = e.target;
  if (Ve(t.type) && St(t))
    return $e(t);
  if (t.type === "file" && t.files) {
    const n = Array.from(t.files);
    return t.multiple ? n : n[0];
  }
  if (un(t))
    return Array.from(t.options).filter((n) => n.selected && !n.disabled).map($e);
  if (Vt(t)) {
    const n = Array.from(t.options).find((i) => i.selected);
    return n ? $e(n) : t.value;
  }
  return t.value;
}
function At(e) {
  const t = {};
  return Object.defineProperty(t, "_$$isNormalized", {
    value: !0,
    writable: !1,
    enumerable: !1,
    configurable: !1
  }), e ? oe(e) && e._$$isNormalized ? e : oe(e) ? Object.keys(e).reduce((n, i) => {
    const r = vn(e[i]);
    return e[i] !== !1 && (n[i] = lt(r)), n;
  }, t) : typeof e != "string" ? t : e.split("|").reduce((n, i) => {
    const r = mn(i);
    return r.name && (n[r.name] = lt(r.params)), n;
  }, t) : t;
}
function vn(e) {
  return e === !0 ? [] : Array.isArray(e) || oe(e) ? e : [e];
}
function lt(e) {
  const t = (n) => typeof n == "string" && n[0] === "@" ? gn(n.slice(1)) : n;
  return Array.isArray(e) ? e.map(t) : e instanceof RegExp ? [e] : Object.keys(e).reduce((n, i) => (n[i] = t(e[i]), n), {});
}
const mn = (e) => {
  let t = [];
  const n = e.split(":")[0];
  return e.includes(":") && (t = e.split(":").slice(1).join(":").split(",")), { name: n, params: t };
};
function gn(e) {
  const t = (n) => N(n, e) || n[e];
  return t.__locatorRef = e, t;
}
function yn(e) {
  return Array.isArray(e) ? e.filter(ze) : L(e).filter((t) => ze(e[t])).map((t) => e[t]);
}
const hn = {
  generateMessage: ({ field: e }) => `${e} is not valid.`,
  bails: !0,
  validateOnBlur: !0,
  validateOnChange: !0,
  validateOnInput: !1,
  validateOnModelUpdate: !0
};
let bn = Object.assign({}, hn);
const Ye = () => bn;
async function wt(e, t, n = {}) {
  const i = n?.bails, r = {
    name: n?.name || "{field}",
    rules: t,
    bails: i ?? !0,
    formData: n?.values || {}
  }, l = (await pn(r, e)).errors;
  return {
    errors: l,
    valid: !l.length
  };
}
async function pn(e, t) {
  if (we(e.rules))
    return Vn(t, e.rules, { bails: e.bails });
  if (pe(e.rules) || Array.isArray(e.rules)) {
    const l = {
      field: e.name,
      form: e.formData,
      value: t
    }, s = Array.isArray(e.rules) ? e.rules : [e.rules], o = s.length, f = [];
    for (let b = 0; b < o; b++) {
      const h = s[b], O = await h(t, l);
      if (typeof O != "string" && O)
        continue;
      const T = typeof O == "string" ? O : Et(l);
      if (f.push(T), e.bails)
        return {
          errors: f
        };
    }
    return {
      errors: f
    };
  }
  const n = Object.assign(Object.assign({}, e), { rules: At(e.rules) }), i = [], r = Object.keys(n.rules), a = r.length;
  for (let l = 0; l < a; l++) {
    const s = r[l], o = await On(n, t, {
      name: s,
      params: n.rules[s]
    });
    if (o.error && (i.push(o.error), e.bails))
      return {
        errors: i
      };
  }
  return {
    errors: i
  };
}
async function Vn(e, t, n) {
  var i;
  return {
    errors: await t.validate(e, {
      abortEarly: (i = n.bails) !== null && i !== void 0 ? i : !0
    }).then(() => []).catch((a) => {
      if (a.name === "ValidationError")
        return a.errors;
      throw a;
    })
  };
}
async function On(e, t, n) {
  const i = rn(n.name);
  if (!i)
    throw new Error(`No such validator '${n.name}' exists.`);
  const r = Sn(n.params, e.formData), a = {
    field: e.name,
    value: t,
    form: e.formData,
    rule: Object.assign(Object.assign({}, n), { params: r })
  }, l = await i(t, r, a);
  return typeof l == "string" ? {
    error: l
  } : {
    error: l ? void 0 : Et(a)
  };
}
function Et(e) {
  const t = Ye().generateMessage;
  return t ? t(e) : "Field is invalid";
}
function Sn(e, t) {
  const n = (i) => ze(i) ? i(t) : i;
  return Array.isArray(e) ? e.map(n) : Object.keys(e).reduce((i, r) => (i[r] = n(e[r]), i), {});
}
async function An(e, t) {
  const n = await e.validate(t, { abortEarly: !1 }).then(() => []).catch((a) => {
    if (a.name !== "ValidationError")
      throw a;
    return a.inner || [];
  }), i = {}, r = {};
  for (const a of n) {
    const l = a.errors;
    i[a.path] = { valid: !l.length, errors: l }, l.length && (r[a.path] = l[0]);
  }
  return {
    valid: !n.length,
    results: i,
    errors: r
  };
}
async function wn(e, t, n) {
  const r = L(e).map(async (f) => {
    var b, h, O;
    const _ = await wt(N(t, f), e[f], {
      name: ((b = n?.names) === null || b === void 0 ? void 0 : b[f]) || f,
      values: t,
      bails: (O = (h = n?.bailsMap) === null || h === void 0 ? void 0 : h[f]) !== null && O !== void 0 ? O : !0
    });
    return Object.assign(Object.assign({}, _), { path: f });
  });
  let a = !0;
  const l = await Promise.all(r), s = {}, o = {};
  for (const f of l)
    s[f.path] = {
      valid: f.valid,
      errors: f.errors
    }, f.valid || (a = !1, o[f.path] = f.errors[0]);
  return {
    valid: a,
    results: s,
    errors: o
  };
}
function ut(e, t, n) {
  typeof n.value == "object" && (n.value = B(n.value)), !n.enumerable || n.get || n.set || !n.configurable || !n.writable || t === "__proto__" ? Object.defineProperty(e, t, n) : e[t] = n.value;
}
function B(e) {
  if (typeof e != "object")
    return e;
  var t = 0, n, i, r, a = Object.prototype.toString.call(e);
  if (a === "[object Object]" ? r = Object.create(e.__proto__ || null) : a === "[object Array]" ? r = Array(e.length) : a === "[object Set]" ? (r = /* @__PURE__ */ new Set(), e.forEach(function(l) {
    r.add(B(l));
  })) : a === "[object Map]" ? (r = /* @__PURE__ */ new Map(), e.forEach(function(l, s) {
    r.set(B(s), B(l));
  })) : a === "[object Date]" ? r = new Date(+e) : a === "[object RegExp]" ? r = new RegExp(e.source, e.flags) : a === "[object DataView]" ? r = new e.constructor(B(e.buffer)) : a === "[object ArrayBuffer]" ? r = e.slice(0) : a.slice(-6) === "Array]" && (r = new e.constructor(e)), r) {
    for (i = Object.getOwnPropertySymbols(e); t < i.length; t++)
      ut(r, i[t], Object.getOwnPropertyDescriptor(e, i[t]));
    for (t = 0, i = Object.getOwnPropertyNames(e); t < i.length; t++)
      Object.hasOwnProperty.call(r, n = i[t]) && r[n] === e[n] || ut(r, n, Object.getOwnPropertyDescriptor(e, n));
  }
  return r || e;
}
var ue = function e(t, n) {
  if (t === n)
    return !0;
  if (t && n && typeof t == "object" && typeof n == "object") {
    if (t.constructor !== n.constructor)
      return !1;
    var i, r, a;
    if (Array.isArray(t)) {
      if (i = t.length, i != n.length)
        return !1;
      for (r = i; r-- !== 0; )
        if (!e(t[r], n[r]))
          return !1;
      return !0;
    }
    if (t instanceof Map && n instanceof Map) {
      if (t.size !== n.size)
        return !1;
      for (r of t.entries())
        if (!n.has(r[0]))
          return !1;
      for (r of t.entries())
        if (!e(r[1], n.get(r[0])))
          return !1;
      return !0;
    }
    if (t instanceof Set && n instanceof Set) {
      if (t.size !== n.size)
        return !1;
      for (r of t.entries())
        if (!n.has(r[0]))
          return !1;
      return !0;
    }
    if (ArrayBuffer.isView(t) && ArrayBuffer.isView(n)) {
      if (i = t.length, i != n.length)
        return !1;
      for (r = i; r-- !== 0; )
        if (t[r] !== n[r])
          return !1;
      return !0;
    }
    if (t.constructor === RegExp)
      return t.source === n.source && t.flags === n.flags;
    if (t.valueOf !== Object.prototype.valueOf)
      return t.valueOf() === n.valueOf();
    if (t.toString !== Object.prototype.toString)
      return t.toString() === n.toString();
    if (a = Object.keys(t), i = a.length, i !== Object.keys(n).length)
      return !1;
    for (r = i; r-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(n, a[r]))
        return !1;
    for (r = i; r-- !== 0; ) {
      var l = a[r];
      if (!e(t[l], n[l]))
        return !1;
    }
    return !0;
  }
  return t !== t && n !== n;
};
let ot = 0;
function En(e, t) {
  const { value: n, initialValue: i, setInitialValue: r } = Ft(e, t.modelValue, !t.standalone), { errorMessage: a, errors: l, setErrors: s } = _n(e, !t.standalone), o = Fn(n, i, l), f = ot >= Number.MAX_SAFE_INTEGER ? 0 : ++ot;
  function b(h) {
    var O;
    "value" in h && (n.value = h.value), "errors" in h && s(h.errors), "touched" in h && (o.touched = (O = h.touched) !== null && O !== void 0 ? O : o.touched), "initialValue" in h && r(h.initialValue);
  }
  return {
    id: f,
    path: e,
    value: n,
    initialValue: i,
    meta: o,
    errors: l,
    errorMessage: a,
    setState: b
  };
}
function Ft(e, t, n = !0) {
  const i = n === !0 ? Ie(ce, void 0) : void 0, r = X(d(t));
  function a() {
    return i ? N(i.meta.value.initialValues, d(e), d(r)) : d(r);
  }
  function l(b) {
    if (!i) {
      r.value = b;
      return;
    }
    i.setFieldInitialValue(d(e), b);
  }
  const s = D(a);
  if (!i)
    return {
      value: X(a()),
      initialValue: s,
      setInitialValue: l
    };
  const o = t ? d(t) : N(i.values, d(e), d(s));
  return i.stageInitialValue(d(e), o, !0), {
    value: D({
      get() {
        return N(i.values, d(e));
      },
      set(b) {
        i.setFieldValue(d(e), b);
      }
    }),
    initialValue: s,
    setInitialValue: l
  };
}
function Fn(e, t, n) {
  const i = Qe({
    touched: !1,
    pending: !1,
    valid: !0,
    validated: !!d(n).length,
    initialValue: D(() => d(t)),
    dirty: D(() => !ue(d(e), d(t)))
  });
  return z(n, (r) => {
    i.valid = !r.length;
  }, {
    immediate: !0,
    flush: "sync"
  }), i;
}
function _n(e, t) {
  const n = t ? Ie(ce, void 0) : void 0;
  function i(a) {
    return a ? Array.isArray(a) ? a : [a] : [];
  }
  if (!n) {
    const a = X([]);
    return {
      errors: a,
      errorMessage: D(() => a.value[0]),
      setErrors: (l) => {
        a.value = i(l);
      }
    };
  }
  const r = D(() => n.errorBag.value[d(e)] || []);
  return {
    errors: r,
    errorMessage: D(() => r.value[0]),
    setErrors: (a) => {
      n.setFieldErrorBag(d(e), i(a));
    }
  };
}
function _t(e) {
  process.env.NODE_ENV !== "production" && en({
    id: "vee-validate-devtools-plugin",
    label: "VeeValidate Plugin",
    packageName: "vee-validate",
    homepage: "https://vee-validate.logaretm.com/v4",
    app: e,
    logo: "https://vee-validate.logaretm.com/v4/logo.png"
  }, In);
}
const Ee = {}, Fe = {};
let ne;
const Oe = dn(() => {
  setTimeout(async () => {
    await he(), ne?.sendInspectorState(be), ne?.sendInspectorTree(be);
  }, 100);
}, 100);
function kn(e) {
  const t = ke();
  if (!ne) {
    const n = t?.appContext.app;
    if (!n)
      return;
    _t(n);
  }
  Ee[e.formId] = Object.assign({}, e), Ee[e.formId]._vm = t, gt(() => {
    delete Ee[e.formId], Oe();
  }), Oe();
}
function Cn(e) {
  const t = ke();
  if (!ne) {
    const n = t?.appContext.app;
    if (!n)
      return;
    _t(n);
  }
  Fe[e.id] = Object.assign({}, e), Fe[e.id]._vm = t, gt(() => {
    delete Fe[e.id], Oe();
  }), Oe();
}
const be = "vee-validate-inspector", G = {
  error: 12405579,
  success: 448379,
  unknown: 5522283,
  white: 16777215,
  black: 0,
  blue: 218007,
  purple: 12157168,
  orange: 16099682,
  gray: 12304330
};
let te = null;
function In(e) {
  ne = e, e.addInspector({
    id: be,
    icon: "rule",
    label: "vee-validate",
    noSelectionText: "Select a vee-validate node to inspect",
    actions: [
      {
        icon: "done_outline",
        tooltip: "Validate selected item",
        action: async () => {
          if (!te) {
            console.error("There is not a valid selected vee-validate node or component");
            return;
          }
          const t = await te.validate();
          console.log(t);
        }
      },
      {
        icon: "delete_sweep",
        tooltip: "Clear validation state of the selected item",
        action: () => {
          if (!te) {
            console.error("There is not a valid selected vee-validate node or component");
            return;
          }
          if ("id" in te) {
            te.resetField();
            return;
          }
          te.resetForm();
        }
      }
    ]
  }), e.on.getInspectorTree((t) => {
    if (t.inspectorId !== be)
      return;
    const n = Object.values(Ee), i = Object.values(Fe);
    t.rootNodes = [
      ...n.map(jn),
      ...i.map((r) => Xe(r))
    ];
  }), e.on.getInspectorState((t, n) => {
    if (t.inspectorId !== be || n.currentTab !== `custom-inspector:${be}`)
      return;
    const { form: i, field: r, type: a } = Nn(t.nodeId);
    if (i && a === "form") {
      t.state = Tn(i), te = i;
      return;
    }
    if (r && a === "field") {
      t.state = Bn(r), te = r;
      return;
    }
    te = null;
  });
}
function jn(e) {
  const { textColor: t, bgColor: n } = Ct(e), i = {};
  Object.values(e.fieldsByPath.value).forEach((l) => {
    const s = Array.isArray(l) ? l[0] : l;
    !s || le(i, d(s.name), Xe(s, e));
  });
  function r(l, s = []) {
    const o = [...s].pop();
    return "id" in l ? Object.assign(Object.assign({}, l), { label: o || l.label }) : oe(l) ? {
      id: `${s.join(".")}`,
      label: o || "",
      children: Object.keys(l).map((f) => r(l[f], [...s, f]))
    } : Array.isArray(l) ? {
      id: `${s.join(".")}`,
      label: `${o}[]`,
      children: l.map((f, b) => r(f, [...s, String(b)]))
    } : { id: "", label: "", children: [] };
  }
  const { children: a } = r(i);
  return {
    id: kt(e),
    label: "Form",
    children: a,
    tags: [
      {
        label: "Form",
        textColor: t,
        backgroundColor: n
      },
      {
        label: `${Object.keys(e.fieldsByPath.value).length} fields`,
        textColor: G.white,
        backgroundColor: G.unknown
      }
    ]
  };
}
function Xe(e, t) {
  const n = cn(e), { textColor: i, bgColor: r } = Ct(n), a = Array.isArray(e) && e.length > 1;
  return {
    id: kt(t, n, !a),
    label: d(n.name),
    children: Array.isArray(e) ? e.map((l) => Xe(l, t)) : void 0,
    tags: [
      a ? void 0 : {
        label: "Field",
        textColor: i,
        backgroundColor: r
      },
      t ? void 0 : {
        label: "Standalone",
        textColor: G.black,
        backgroundColor: G.gray
      },
      !a && n.type === "checkbox" ? {
        label: "Checkbox",
        textColor: G.white,
        backgroundColor: G.blue
      } : void 0,
      !a && n.type === "radio" ? {
        label: "Radio",
        textColor: G.white,
        backgroundColor: G.purple
      } : void 0,
      a ? {
        label: "Group",
        textColor: G.black,
        backgroundColor: G.orange
      } : void 0
    ].filter(Boolean)
  };
}
function kt(e, t, n = !0) {
  const i = e ? d(t?.name) : t?.id, r = i ? e?.fieldsByPath.value[i] : void 0;
  let a;
  n && t && Array.isArray(r) && (a = r.indexOf(t));
  const l = { f: e?.formId, ff: i, idx: a, type: t ? "field" : "form" };
  return btoa(JSON.stringify(l));
}
function Nn(e) {
  try {
    const t = JSON.parse(atob(e)), n = Ee[t.f];
    if (!n && t.ff) {
      const r = Fe[t.ff];
      return r ? {
        type: t.type,
        field: r
      } : {};
    }
    if (!n)
      return {};
    const i = n.fieldsByPath.value[t.ff];
    return {
      type: t.type,
      form: n,
      field: Array.isArray(i) ? i[t.idx || 0] : i
    };
  } catch {
  }
  return {};
}
function Bn(e) {
  const { errors: t, meta: n, value: i } = e;
  return {
    "Field state": [
      { key: "errors", value: t.value },
      {
        key: "initialValue",
        value: n.initialValue
      },
      {
        key: "currentValue",
        value: i.value
      },
      {
        key: "touched",
        value: n.touched
      },
      {
        key: "dirty",
        value: n.dirty
      },
      {
        key: "valid",
        value: n.valid
      }
    ]
  };
}
function Tn(e) {
  const { errorBag: t, meta: n, values: i, isSubmitting: r, submitCount: a } = e;
  return {
    "Form state": [
      {
        key: "submitCount",
        value: a.value
      },
      {
        key: "isSubmitting",
        value: r.value
      },
      {
        key: "touched",
        value: n.value.touched
      },
      {
        key: "dirty",
        value: n.value.dirty
      },
      {
        key: "valid",
        value: n.value.valid
      },
      {
        key: "initialValues",
        value: n.value.initialValues
      },
      {
        key: "currentValues",
        value: i
      },
      {
        key: "errors",
        value: L(t.value).reduce((l, s) => {
          var o;
          const f = (o = t.value[s]) === null || o === void 0 ? void 0 : o[0];
          return f && (l[s] = f), l;
        }, {})
      }
    ]
  };
}
function Ct(e) {
  const t = "id" in e ? e.meta.valid : e.meta.value.valid;
  return {
    bgColor: t ? G.success : G.error,
    textColor: t ? G.black : G.white
  };
}
function It(e, t, n) {
  return Ve(n?.type) ? Rn(e, t, n) : jt(e, t, n);
}
function jt(e, t, n) {
  const { initialValue: i, validateOnMount: r, bails: a, type: l, checkedValue: s, label: o, validateOnValueUpdate: f, uncheckedValue: b, standalone: h, keepValueOnUnmount: O, modelPropName: _, syncVModel: T } = Mn(d(e), n), F = h ? void 0 : Ie(ce);
  let H = !1;
  const { id: $, value: M, initialValue: g, meta: m, setState: w, errors: p, errorMessage: E } = En(e, {
    modelValue: i,
    standalone: h
  });
  T && Dn({ value: M, prop: _, handleChange: q });
  const V = () => {
    m.touched = !0;
  }, I = D(() => {
    let v = d(t);
    const C = d(F?.schema);
    return C && !we(C) && (v = Pn(C, d(e)) || v), we(v) || pe(v) || Array.isArray(v) ? v : At(v);
  });
  async function k(v) {
    var C, U;
    return F?.validateSchema ? (C = (await F.validateSchema(v)).results[d(e)]) !== null && C !== void 0 ? C : { valid: !0, errors: [] } : wt(M.value, I.value, {
      name: d(o) || d(e),
      values: (U = F?.values) !== null && U !== void 0 ? U : {},
      bails: a
    });
  }
  async function j() {
    m.pending = !0, m.validated = !0;
    const v = await k("validated-only");
    return H && (v.valid = !0, v.errors = []), w({ errors: v.errors }), m.pending = !1, v;
  }
  async function P() {
    const v = await k("silent");
    return H && (v.valid = !0), m.valid = v.valid, v;
  }
  function Q(v) {
    return !v?.mode || v?.mode === "force" || v?.mode === "validated-only" ? j() : P();
  }
  function q(v, C = !0) {
    const U = Je(v);
    M.value = U, !f && C && j();
  }
  dt(() => {
    if (r)
      return j();
    (!F || !F.validateSchema) && P();
  });
  function K(v) {
    m.touched = v;
  }
  let Z;
  function W() {
    Z = z(M, (v, C) => {
      if (ue(v, C))
        return;
      (f ? j : P)();
    }, {
      deep: !0
    });
  }
  W();
  function se(v) {
    var C;
    Z?.();
    const U = v && "value" in v ? v.value : g.value;
    w({
      value: B(U),
      initialValue: B(U),
      touched: (C = v?.touched) !== null && C !== void 0 ? C : !1,
      errors: v?.errors || []
    }), m.pending = !1, m.validated = !1, P(), he(() => {
      W();
    });
  }
  function ie(v) {
    M.value = v;
  }
  function de(v) {
    w({ errors: Array.isArray(v) ? v : [v] });
  }
  const J = {
    id: $,
    name: e,
    label: o,
    value: M,
    meta: m,
    errors: p,
    errorMessage: E,
    type: l,
    checkedValue: s,
    uncheckedValue: b,
    bails: a,
    keepValueOnUnmount: O,
    resetField: se,
    handleReset: () => se(),
    validate: Q,
    handleChange: q,
    handleBlur: V,
    setState: w,
    setTouched: K,
    setErrors: de,
    setValue: ie
  };
  if (ft(an, J), _e(t) && typeof d(t) != "function" && z(t, (v, C) => {
    ue(v, C) || (m.validated ? j() : P());
  }, {
    deep: !0
  }), process.env.NODE_ENV !== "production" && (J._vm = ke(), z(() => Object.assign(Object.assign({ errors: p.value }, m), { value: M.value }), Oe, {
    deep: !0
  }), F || Cn(J)), !F)
    return J;
  F.register(J), vt(() => {
    H = !0, F.unregister(J);
  });
  const je = D(() => {
    const v = I.value;
    return !v || pe(v) || we(v) || Array.isArray(v) ? {} : Object.keys(v).reduce((C, U) => {
      const fe = yn(v[U]).map((ae) => ae.__locatorRef).reduce((ae, ve) => {
        const Ne = N(F.values, ve) || F.values[ve];
        return Ne !== void 0 && (ae[ve] = Ne), ae;
      }, {});
      return Object.assign(C, fe), C;
    }, {});
  });
  return z(je, (v, C) => {
    if (!Object.keys(v).length)
      return;
    !ue(v, C) && (m.validated ? j() : P());
  }), J;
}
function Mn(e, t) {
  const n = () => ({
    initialValue: void 0,
    validateOnMount: !1,
    bails: !0,
    rules: "",
    label: e,
    validateOnValueUpdate: !0,
    standalone: !1,
    keepValueOnUnmount: void 0,
    modelPropName: "modelValue",
    syncVModel: !0
  });
  if (!t)
    return n();
  const i = "valueProp" in t ? t.valueProp : t.checkedValue;
  return Object.assign(Object.assign(Object.assign({}, n()), t || {}), { checkedValue: i });
}
function Pn(e, t) {
  if (!!e)
    return e[t];
}
function Rn(e, t, n) {
  const i = n?.standalone ? void 0 : Ie(ce), r = n?.checkedValue, a = n?.uncheckedValue;
  function l(s) {
    const o = s.handleChange, f = D(() => {
      const h = d(s.value), O = d(r);
      return Array.isArray(h) ? h.includes(O) : O === h;
    });
    function b(h, O = !0) {
      var _;
      if (f.value === ((_ = h?.target) === null || _ === void 0 ? void 0 : _.checked))
        return;
      let T = Je(h);
      i || (T = He(d(s.value), d(r), d(a))), o(T, O);
    }
    return Object.assign(Object.assign({}, s), {
      checked: f,
      checkedValue: r,
      uncheckedValue: a,
      handleChange: b
    });
  }
  return l(jt(e, t, n));
}
function Dn({ prop: e, value: t, handleChange: n }) {
  const i = ke();
  if (!i) {
    process.env.NODE_ENV !== "production" && console.warn("Failed to setup model events because `useField` was not called in setup.");
    return;
  }
  const r = e || "modelValue", a = `update:${r}`;
  r in i.props && (z(t, (l) => {
    ue(l, st(i, r)) || i.emit(a, l);
  }), z(() => st(i, r), (l) => {
    if (l === Te && t.value === void 0)
      return;
    const s = l === Te ? void 0 : l;
    ue(s, fn(t.value, i.props.modelModifiers)) || n(s);
  }));
}
function st(e, t) {
  return e.props[t];
}
Ce({
  name: "Field",
  inheritAttrs: !1,
  props: {
    as: {
      type: [String, Object],
      default: void 0
    },
    name: {
      type: String,
      required: !0
    },
    rules: {
      type: [Object, String, Function],
      default: void 0
    },
    validateOnMount: {
      type: Boolean,
      default: !1
    },
    validateOnBlur: {
      type: Boolean,
      default: void 0
    },
    validateOnChange: {
      type: Boolean,
      default: void 0
    },
    validateOnInput: {
      type: Boolean,
      default: void 0
    },
    validateOnModelUpdate: {
      type: Boolean,
      default: void 0
    },
    bails: {
      type: Boolean,
      default: () => Ye().bails
    },
    label: {
      type: String,
      default: void 0
    },
    uncheckedValue: {
      type: null,
      default: void 0
    },
    modelValue: {
      type: null,
      default: Te
    },
    modelModifiers: {
      type: null,
      default: () => ({})
    },
    "onUpdate:modelValue": {
      type: null,
      default: void 0
    },
    standalone: {
      type: Boolean,
      default: !1
    },
    keepValue: {
      type: Boolean,
      default: void 0
    }
  },
  setup(e, t) {
    const n = re(e, "rules"), i = re(e, "name"), r = re(e, "label"), a = re(e, "uncheckedValue"), l = re(e, "keepValue"), { errors: s, value: o, errorMessage: f, validate: b, handleChange: h, handleBlur: O, setTouched: _, resetField: T, handleReset: F, meta: H, checked: $, setErrors: M } = It(i, n, {
      validateOnMount: e.validateOnMount,
      bails: e.bails,
      standalone: e.standalone,
      type: t.attrs.type,
      initialValue: Ln(e, t),
      checkedValue: t.attrs.value,
      uncheckedValue: a,
      label: r,
      validateOnValueUpdate: !1,
      keepValueOnUnmount: l
    }), g = function(I, k = !0) {
      h(I, k), t.emit("update:modelValue", o.value);
    }, m = (V) => {
      Ve(t.attrs.type) || (o.value = Je(V));
    }, w = function(I) {
      m(I), t.emit("update:modelValue", o.value);
    }, p = D(() => {
      const { validateOnInput: V, validateOnChange: I, validateOnBlur: k, validateOnModelUpdate: j } = Un(e), P = [O, t.attrs.onBlur, k ? b : void 0].filter(Boolean), Q = [(W) => g(W, V), t.attrs.onInput].filter(Boolean), q = [(W) => g(W, I), t.attrs.onChange].filter(Boolean), K = {
        name: e.name,
        onBlur: P,
        onInput: Q,
        onChange: q
      };
      K["onUpdate:modelValue"] = (W) => g(W, j), Ve(t.attrs.type) && $ && (K.checked = $.value);
      const Z = ct(e, t);
      return sn(Z, t.attrs) && (K.value = o.value), K;
    });
    function E() {
      return {
        field: p.value,
        value: o.value,
        meta: H,
        errors: s.value,
        errorMessage: f.value,
        validate: b,
        resetField: T,
        handleChange: g,
        handleInput: w,
        handleReset: F,
        handleBlur: O,
        setTouched: _,
        setErrors: M
      };
    }
    return t.expose({
      setErrors: M,
      setTouched: _,
      reset: T,
      validate: b,
      handleChange: h
    }), () => {
      const V = Ke(ct(e, t)), I = Pe(V, t, E);
      return V ? Be(V, Object.assign(Object.assign({}, t.attrs), p.value), I) : I;
    };
  }
});
function ct(e, t) {
  let n = e.as || "";
  return !e.as && !t.slots.default && (n = "input"), n;
}
function Un(e) {
  var t, n, i, r;
  const { validateOnInput: a, validateOnChange: l, validateOnBlur: s, validateOnModelUpdate: o } = Ye();
  return {
    validateOnInput: (t = e.validateOnInput) !== null && t !== void 0 ? t : a,
    validateOnChange: (n = e.validateOnChange) !== null && n !== void 0 ? n : l,
    validateOnBlur: (i = e.validateOnBlur) !== null && i !== void 0 ? i : s,
    validateOnModelUpdate: (r = e.validateOnModelUpdate) !== null && r !== void 0 ? r : o
  };
}
function Ln(e, t) {
  return Ve(t.attrs.type) ? it(e, "modelValue") ? e.modelValue : void 0 : it(e, "modelValue") ? e.modelValue : t.attrs.value;
}
let xn = 0;
function $n(e) {
  var t;
  const n = xn++;
  let i = !1;
  const r = X({}), a = X(!1), l = X(0), s = [], o = Qe(B(d(e?.initialValues) || {})), { errorBag: f, setErrorBag: b, setFieldErrorBag: h } = Hn(e?.initialErrors), O = D(() => L(f.value).reduce((u, c) => {
    const S = f.value[c];
    return S && S.length && (u[c] = S[0]), u;
  }, {}));
  function _(u) {
    const c = r.value[u];
    return Array.isArray(c) ? c[0] : c;
  }
  function T(u) {
    return !!r.value[u];
  }
  const F = D(() => L(r.value).reduce((u, c) => {
    const S = _(c);
    return S && (u[c] = d(S.label || S.name) || ""), u;
  }, {})), H = D(() => L(r.value).reduce((u, c) => {
    var S;
    const A = _(c);
    return A && (u[c] = (S = A.bails) !== null && S !== void 0 ? S : !0), u;
  }, {})), $ = Object.assign({}, e?.initialErrors || {}), M = (t = e?.keepValuesOnUnmount) !== null && t !== void 0 ? t : !1, { initialValues: g, originalInitialValues: m, setInitialValues: w } = zn(r, o, e?.initialValues), p = Gn(r, o, m, O), E = e?.validationSchema, V = {
    formId: n,
    fieldsByPath: r,
    values: o,
    errorBag: f,
    errors: O,
    schema: E,
    submitCount: l,
    meta: p,
    isSubmitting: a,
    fieldArrays: s,
    keepValuesOnUnmount: M,
    validateSchema: d(E) ? Mt : void 0,
    validate: U,
    register: v,
    unregister: C,
    setFieldErrorBag: h,
    validateField: fe,
    setFieldValue: q,
    setValues: K,
    setErrors: Q,
    setFieldError: P,
    setFieldTouched: se,
    setTouched: ie,
    resetForm: de,
    handleSubmit: ae,
    stageInitialValue: Nt,
    unsetInitialValue: Ne,
    setFieldInitialValue: ve,
    useFieldModel: W
  };
  function I(u) {
    return Array.isArray(u);
  }
  function k(u, c) {
    return Array.isArray(u) ? u.forEach(c) : c(u);
  }
  function j(u) {
    Object.values(r.value).forEach((c) => {
      !c || k(c, u);
    });
  }
  function P(u, c) {
    h(u, c);
  }
  function Q(u) {
    b(u);
  }
  function q(u, c, { force: S } = { force: !1 }) {
    var A;
    const y = r.value[u], R = B(c);
    if (!y) {
      le(o, u, R);
      return;
    }
    if (I(y) && ((A = y[0]) === null || A === void 0 ? void 0 : A.type) === "checkbox" && !Array.isArray(c)) {
      const ee = B(He(N(o, u) || [], c, void 0));
      le(o, u, ee);
      return;
    }
    let x = c;
    !I(y) && y.type === "checkbox" && !S && !i && (x = B(He(N(o, u), c, d(y.uncheckedValue)))), le(o, u, x);
  }
  function K(u) {
    L(o).forEach((c) => {
      delete o[c];
    }), L(u).forEach((c) => {
      q(c, u[c]);
    }), s.forEach((c) => c && c.reset());
  }
  function Z(u) {
    const { value: c } = Ft(u);
    return z(c, () => {
      T(d(u)) || U({ mode: "validated-only" });
    }), c;
  }
  function W(u) {
    return Array.isArray(u) ? u.map(Z) : Z(u);
  }
  function se(u, c) {
    const S = r.value[u];
    S && k(S, (A) => A.setTouched(c));
  }
  function ie(u) {
    L(u).forEach((c) => {
      se(c, !!u[c]);
    });
  }
  function de(u) {
    i = !0, u?.values ? (w(u.values), K(u?.values)) : (w(m.value), K(m.value)), j((c) => c.resetField()), u?.touched && ie(u.touched), Q(u?.errors || {}), l.value = u?.submitCount || 0, he(() => {
      i = !1;
    });
  }
  function J(u, c) {
    const S = Ut(u), A = c;
    if (!r.value[A]) {
      r.value[A] = S;
      return;
    }
    const y = r.value[A];
    y && !Array.isArray(y) && (r.value[A] = [y]), r.value[A] = [...r.value[A], S];
  }
  function je(u, c) {
    const S = c, A = r.value[S];
    if (!!A) {
      if (!I(A) && u.id === A.id) {
        delete r.value[S];
        return;
      }
      if (I(A)) {
        const y = A.findIndex((R) => R.id === u.id);
        if (y === -1)
          return;
        A.splice(y, 1), A.length || delete r.value[S];
      }
    }
  }
  function v(u) {
    const c = d(u.name);
    J(u, c), _e(u.name) && z(u.name, async (A, y) => {
      await he(), je(u, y), J(u, A), (O.value[y] || O.value[A]) && (P(y, void 0), fe(A)), await he(), T(y) || Le(o, y);
    });
    const S = d(u.errorMessage);
    S && $?.[c] !== S && fe(c), delete $[c];
  }
  function C(u) {
    const c = d(u.name), S = r.value[c], A = !!S && I(S);
    je(u, c), he(() => {
      var y;
      const R = (y = d(u.keepValueOnUnmount)) !== null && y !== void 0 ? y : d(M), x = N(o, c);
      if (A && (S === r.value[c] || !r.value[c]) && Array.isArray(x) && !R) {
        const me = x.findIndex((Y) => ue(Y, d(u.checkedValue)));
        if (me > -1) {
          const Y = [...x];
          Y.splice(me, 1), q(c, Y, { force: !0 });
        }
      }
      if (!T(c)) {
        if (P(c, void 0), R || A && !pt(N(o, c)))
          return;
        Le(o, c);
      }
    });
  }
  async function U(u) {
    if (j((y) => y.meta.validated = !0), V.validateSchema)
      return V.validateSchema(u?.mode || "force");
    const c = await Promise.all(Object.values(r.value).map((y) => {
      const R = Array.isArray(y) ? y[0] : y;
      return R ? R.validate(u).then((x) => ({
        key: d(R.name),
        valid: x.valid,
        errors: x.errors
      })) : Promise.resolve({ key: "", valid: !0, errors: [] });
    })), S = {}, A = {};
    for (const y of c)
      S[y.key] = {
        valid: y.valid,
        errors: y.errors
      }, y.errors.length && (A[y.key] = y.errors[0]);
    return {
      valid: c.every((y) => y.valid),
      results: S,
      errors: A
    };
  }
  async function fe(u) {
    const c = r.value[u];
    return c ? Array.isArray(c) ? c.map((S) => S.validate())[0] : c.validate() : (yt(`field with name ${u} was not found`), Promise.resolve({ errors: [], valid: !0 }));
  }
  function ae(u, c) {
    return function(A) {
      return A instanceof Event && (A.preventDefault(), A.stopPropagation()), ie(L(r.value).reduce((y, R) => (y[R] = !0, y), {})), a.value = !0, l.value++, U().then((y) => {
        if (y.valid && typeof u == "function")
          return u(B(o), {
            evt: A,
            setErrors: Q,
            setFieldError: P,
            setTouched: ie,
            setFieldTouched: se,
            setValues: K,
            setFieldValue: q,
            resetForm: de
          });
        !y.valid && typeof c == "function" && c({
          values: B(o),
          evt: A,
          errors: y.errors,
          results: y.results
        });
      }).then((y) => (a.value = !1, y), (y) => {
        throw a.value = !1, y;
      });
    };
  }
  function ve(u, c) {
    le(g.value, u, B(c));
  }
  function Ne(u) {
    Le(g.value, u);
  }
  function Nt(u, c, S = !1) {
    le(o, u, c), ve(u, c), S && le(m.value, u, B(c));
  }
  async function Ze() {
    const u = d(E);
    return u ? we(u) ? await An(u, o) : await wn(u, o, {
      names: F.value,
      bailsMap: H.value
    }) : { valid: !0, results: {}, errors: {} };
  }
  const Bt = at(Ze, 5), Tt = at(Ze, 5);
  async function Mt(u) {
    const c = await (u === "silent" ? Bt() : Tt()), S = V.fieldsByPath.value || {}, A = L(V.errorBag.value);
    return [
      .../* @__PURE__ */ new Set([...L(c.results), ...L(S), ...A])
    ].reduce((R, x) => {
      const ee = S[x], me = (c.results[x] || { errors: [] }).errors, Y = {
        errors: me,
        valid: !me.length
      };
      if (R.results[x] = Y, Y.valid || (R.errors[x] = Y.errors[0]), !ee)
        return P(x, me), R;
      if (k(ee, (Se) => Se.meta.valid = Y.valid), u === "silent")
        return R;
      const Rt = Array.isArray(ee) ? ee.some((Se) => Se.meta.validated) : ee.meta.validated;
      return u === "validated-only" && !Rt || k(ee, (Se) => Se.setState({ errors: Y.errors })), R;
    }, { valid: c.valid, results: {}, errors: {} });
  }
  const Pt = ae((u, { evt: c }) => {
    Ot(c) && c.target.submit();
  });
  return dt(() => {
    if (e?.initialErrors && Q(e.initialErrors), e?.initialTouched && ie(e.initialTouched), e?.validateOnMount) {
      U();
      return;
    }
    V.validateSchema && V.validateSchema("silent");
  }), _e(E) && z(E, () => {
    var u;
    (u = V.validateSchema) === null || u === void 0 || u.call(V, "validated-only");
  }), ft(ce, V), process.env.NODE_ENV !== "production" && (kn(V), z(() => Object.assign(Object.assign({ errors: f.value }, p.value), { values: o, isSubmitting: a.value, submitCount: l.value }), Oe, {
    deep: !0
  })), {
    errors: O,
    meta: p,
    values: o,
    isSubmitting: a,
    submitCount: l,
    validate: U,
    validateField: fe,
    handleReset: () => de(),
    resetForm: de,
    handleSubmit: ae,
    submitForm: Pt,
    setFieldError: P,
    setErrors: Q,
    setFieldValue: q,
    setValues: K,
    setFieldTouched: se,
    setTouched: ie,
    useFieldModel: W
  };
}
function Gn(e, t, n, i) {
  const r = {
    touched: "some",
    pending: "some",
    valid: "every"
  }, a = D(() => !ue(t, d(n)));
  function l() {
    const o = Object.values(e.value).flat(1).filter(Boolean);
    return L(r).reduce((f, b) => {
      const h = r[b];
      return f[b] = o[h]((O) => O.meta[b]), f;
    }, {});
  }
  const s = Qe(l());
  return Dt(() => {
    const o = l();
    s.touched = o.touched, s.valid = o.valid, s.pending = o.pending;
  }), D(() => Object.assign(Object.assign({ initialValues: d(n) }, s), { valid: s.valid && !L(i.value).length, dirty: a.value }));
}
function zn(e, t, n) {
  const i = X(B(d(n)) || {}), r = X(B(d(n)) || {});
  function a(l, s = !1) {
    i.value = B(l), r.value = B(l), s && L(e.value).forEach((o) => {
      const f = e.value[o], b = Array.isArray(f) ? f.some((O) => O.meta.touched) : f?.meta.touched;
      if (!f || b)
        return;
      const h = N(i.value, o);
      le(t, o, B(h));
    });
  }
  return _e(n) && z(n, (l) => {
    a(l, !0);
  }, {
    deep: !0
  }), {
    initialValues: i,
    originalInitialValues: r,
    setInitialValues: a
  };
}
function Hn(e) {
  const t = X({});
  function n(a) {
    return Array.isArray(a) ? a : a ? [a] : [];
  }
  function i(a, l) {
    if (!l) {
      delete t.value[a];
      return;
    }
    t.value[a] = n(l);
  }
  function r(a) {
    t.value = L(a).reduce((l, s) => {
      const o = a[s];
      return o && (l[s] = n(o)), l;
    }, {});
  }
  return e && r(e), {
    errorBag: t,
    setErrorBag: r,
    setFieldErrorBag: i
  };
}
Ce({
  name: "Form",
  inheritAttrs: !1,
  props: {
    as: {
      type: String,
      default: "form"
    },
    validationSchema: {
      type: Object,
      default: void 0
    },
    initialValues: {
      type: Object,
      default: void 0
    },
    initialErrors: {
      type: Object,
      default: void 0
    },
    initialTouched: {
      type: Object,
      default: void 0
    },
    validateOnMount: {
      type: Boolean,
      default: !1
    },
    onSubmit: {
      type: Function,
      default: void 0
    },
    onInvalidSubmit: {
      type: Function,
      default: void 0
    },
    keepValues: {
      type: Boolean,
      default: !1
    }
  },
  setup(e, t) {
    const n = re(e, "initialValues"), i = re(e, "validationSchema"), r = re(e, "keepValues"), { errors: a, values: l, meta: s, isSubmitting: o, submitCount: f, validate: b, validateField: h, handleReset: O, resetForm: _, handleSubmit: T, setErrors: F, setFieldError: H, setFieldValue: $, setValues: M, setFieldTouched: g, setTouched: m } = $n({
      validationSchema: i.value ? i : void 0,
      initialValues: n,
      initialErrors: e.initialErrors,
      initialTouched: e.initialTouched,
      validateOnMount: e.validateOnMount,
      keepValuesOnUnmount: r
    }), w = T((k, { evt: j }) => {
      Ot(j) && j.target.submit();
    }, e.onInvalidSubmit), p = e.onSubmit ? T(e.onSubmit, e.onInvalidSubmit) : w;
    function E(k) {
      We(k) && k.preventDefault(), O(), typeof t.attrs.onReset == "function" && t.attrs.onReset();
    }
    function V(k, j) {
      return T(typeof k == "function" && !j ? k : j, e.onInvalidSubmit)(k);
    }
    function I() {
      return {
        meta: s.value,
        errors: a.value,
        values: l,
        isSubmitting: o.value,
        submitCount: f.value,
        validate: b,
        validateField: h,
        handleSubmit: V,
        handleReset: O,
        submitForm: w,
        setErrors: F,
        setFieldError: H,
        setFieldValue: $,
        setValues: M,
        setFieldTouched: g,
        setTouched: m,
        resetForm: _
      };
    }
    return t.expose({
      setFieldError: H,
      setErrors: F,
      setFieldValue: $,
      setValues: M,
      setFieldTouched: g,
      setTouched: m,
      resetForm: _,
      validate: b,
      validateField: h
    }), function() {
      const j = e.as === "form" ? e.as : Ke(e.as), P = Pe(j, t, I);
      if (!e.as)
        return P;
      const Q = e.as === "form" ? {
        novalidate: !0
      } : {};
      return Be(j, Object.assign(Object.assign(Object.assign({}, Q), t.attrs), { onSubmit: p, onReset: E }), P);
    };
  }
});
function Kn(e) {
  const t = Ie(ce, void 0), n = X([]), i = () => {
  }, r = {
    fields: n,
    remove: i,
    push: i,
    swap: i,
    insert: i,
    update: i,
    replace: i,
    prepend: i,
    move: i
  };
  if (!t)
    return xe("FieldArray requires being a child of `<Form/>` or `useForm` being called before it. Array fields may not work correctly"), r;
  if (!d(e))
    return xe("FieldArray requires a field path to be provided, did you forget to pass the `name` prop?"), r;
  const a = t.fieldArrays.find((g) => d(g.path) === d(e));
  if (a)
    return a;
  let l = 0;
  function s() {
    const g = N(t?.values, d(e), []) || [];
    n.value = g.map(f), o();
  }
  s();
  function o() {
    const g = n.value.length;
    for (let m = 0; m < g; m++) {
      const w = n.value[m];
      w.isFirst = m === 0, w.isLast = m === g - 1;
    }
  }
  function f(g) {
    const m = l++;
    return {
      key: m,
      value: D({
        get() {
          const p = N(t?.values, d(e), []) || [], E = n.value.findIndex((V) => V.key === m);
          return E === -1 ? g : p[E];
        },
        set(p) {
          const E = n.value.findIndex((V) => V.key === m);
          if (E === -1) {
            xe("Attempting to update a non-existent array item");
            return;
          }
          F(E, p);
        }
      }),
      isFirst: !1,
      isLast: !1
    };
  }
  function b(g) {
    const m = d(e), w = N(t?.values, m);
    if (!w || !Array.isArray(w))
      return;
    const p = [...w];
    p.splice(g, 1), t?.unsetInitialValue(m + `[${g}]`), t?.setFieldValue(m, p), n.value.splice(g, 1), o();
  }
  function h(g) {
    const m = d(e), w = N(t?.values, m), p = Ae(w) ? [] : w;
    if (!Array.isArray(p))
      return;
    const E = [...p];
    E.push(g), t?.stageInitialValue(m + `[${E.length - 1}]`, g), t?.setFieldValue(m, E), n.value.push(f(g)), o();
  }
  function O(g, m) {
    const w = d(e), p = N(t?.values, w);
    if (!Array.isArray(p) || !(g in p) || !(m in p))
      return;
    const E = [...p], V = [...n.value], I = E[g];
    E[g] = E[m], E[m] = I;
    const k = V[g];
    V[g] = V[m], V[m] = k, t?.setFieldValue(w, E), n.value = V, o();
  }
  function _(g, m) {
    const w = d(e), p = N(t?.values, w);
    if (!Array.isArray(p) || p.length < g)
      return;
    const E = [...p], V = [...n.value];
    E.splice(g, 0, m), V.splice(g, 0, f(m)), t?.setFieldValue(w, E), n.value = V, o();
  }
  function T(g) {
    const m = d(e);
    t?.setFieldValue(m, g), s();
  }
  function F(g, m) {
    const w = d(e), p = N(t?.values, w);
    !Array.isArray(p) || p.length - 1 < g || t?.setFieldValue(`${w}[${g}]`, m);
  }
  function H(g) {
    const m = d(e), w = N(t?.values, m), p = Ae(w) ? [] : w;
    if (!Array.isArray(p))
      return;
    const E = [g, ...p];
    t?.stageInitialValue(m + `[${E.length - 1}]`, g), t?.setFieldValue(m, E), n.value.unshift(f(g)), o();
  }
  function $(g, m) {
    const w = d(e), p = N(t?.values, w), E = Ae(p) ? [] : [...p];
    if (!Array.isArray(p) || !(g in p) || !(m in p))
      return;
    const V = [...n.value], I = V[g];
    V.splice(g, 1), V.splice(m, 0, I);
    const k = E[g];
    E.splice(g, 1), E.splice(m, 0, k), t?.setFieldValue(w, E), n.value = V, o();
  }
  const M = {
    fields: n,
    remove: b,
    push: h,
    swap: O,
    insert: _,
    update: F,
    replace: T,
    prepend: H,
    move: $
  };
  return t.fieldArrays.push(Object.assign({ path: e, reset: s }, M)), vt(() => {
    const g = t.fieldArrays.findIndex((m) => d(m.path) === d(e));
    g >= 0 && t.fieldArrays.splice(g, 1);
  }), M;
}
Ce({
  name: "FieldArray",
  inheritAttrs: !1,
  props: {
    name: {
      type: String,
      required: !0
    }
  },
  setup(e, t) {
    const { push: n, remove: i, swap: r, insert: a, replace: l, update: s, prepend: o, move: f, fields: b } = Kn(re(e, "name"));
    function h() {
      return {
        fields: b.value,
        push: n,
        remove: i,
        swap: r,
        insert: a,
        update: s,
        replace: l,
        prepend: o,
        move: f
      };
    }
    return t.expose({
      push: n,
      remove: i,
      swap: r,
      insert: a,
      update: s,
      replace: l,
      prepend: o,
      move: f
    }), () => Pe(void 0, t, h);
  }
});
Ce({
  name: "ErrorMessage",
  props: {
    as: {
      type: String,
      default: void 0
    },
    name: {
      type: String,
      required: !0
    }
  },
  setup(e, t) {
    const n = mt(ce, void 0), i = D(() => n?.errors.value[e.name]);
    function r() {
      return {
        message: i.value
      };
    }
    return () => {
      if (!i.value)
        return;
      const a = e.as ? Ke(e.as) : e.as, l = Pe(a, t, r), s = Object.assign({ role: "alert" }, t.attrs);
      return !a && (Array.isArray(l) || !l) && l?.length ? l : (Array.isArray(l) || !l) && !l?.length ? Be(a || "span", s, i.value) : Be(a, s, l);
    };
  }
});
const qn = /* @__PURE__ */ Ce({
  __name: "VSwitch",
  props: {
    modelValue: {
      type: Boolean,
      default: !1
    },
    label: {
      type: String,
      default: ""
    },
    color: {
      type: String,
      default: "primary"
    },
    inactiveClass: {
      type: String,
      default: "bg-gray-200"
    },
    activeClass: {
      type: String,
      default: ""
    },
    buttonClass: {
      type: String,
      default: ""
    },
    wrapperClass: {
      type: String,
      default: ""
    },
    switchClass: {
      type: String,
      default: ""
    },
    switchGroupClass: {
      type: String,
      default: ""
    },
    labelClass: {
      type: String,
      default: ""
    },
    name: {
      type: String,
      default: ""
    },
    rules: {
      type: String,
      default: ""
    },
    errorClass: {
      type: String,
      default: "text-error-600 mt-1 text-sm"
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, { modelValue: i, label: r, name: a, rules: l } = Lt(n), s = {
      primary: "bg-primary-600",
      secondary: "bg-secondary-600",
      info: "bg-info-600",
      warning: "bg-warning-600",
      success: "bg-success-600",
      error: "bg-error-600",
      default: ""
    }, o = D(
      () => n.color ? s[n.color] : s.default
    ), { value: f, errorMessage: b } = It(a, l, {
      initialValue: i.value
    });
    return z(f, (h) => {
      t("update:modelValue", h);
    }), z(i, (h) => {
      f.value = h;
    }), (h, O) => (Re(), et("div", {
      class: ge(["w-full", e.wrapperClass])
    }, [
      tt(d(zt), {
        as: "div",
        class: ge(["flex items-center gap-4", e.switchGroupClass])
      }, {
        default: De(() => [
          d(r) ? (Re(), xt(d(Ht), {
            key: 0,
            class: ge(e.labelClass)
          }, {
            default: De(() => [
              $t(nt(d(r)), 1)
            ]),
            _: 1
          }, 8, ["class"])) : rt("", !0),
          tt(d(Kt), {
            modelValue: d(f),
            "onUpdate:modelValue": O[0] || (O[0] = (_) => _e(f) ? f.value = _ : null),
            as: "button",
            class: ge(["relative inline-flex flex-shrink-0 h-6 transition-colors duration-200 ease-in-out border-2 border-transparent rounded-full cursor-pointer w-11 focus:outline-none focus:shadow-outline", [
              d(f) ? d(o) ?? e.activeClass : e.inactiveClass,
              e.switchClass
            ]])
          }, {
            default: De(({ checked: _ }) => [
              Gt("span", {
                class: ge(["inline-block w-5 h-5 transition duration-200 ease-in-out transform bg-white rounded-full", [
                  { "translate-x-5": _, "translate-x-0": !_ },
                  e.buttonClass
                ]])
              }, null, 2)
            ]),
            _: 1
          }, 8, ["modelValue", "class"])
        ]),
        _: 1
      }, 8, ["class"]),
      d(b) ? (Re(), et("div", {
        key: 0,
        class: ge(e.errorClass)
      }, nt(d(b)), 3)) : rt("", !0)
    ], 2));
  }
});
export {
  qn as VSwitch,
  qn as default
};
