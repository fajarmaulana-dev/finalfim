import { openBlock, createElementBlock, normalizeClass, renderSlot, defineComponent, toRefs, ref, watch, createElementVNode, unref, createTextVNode, toDisplayString, createBlock, createCommentVNode, createVNode, withCtx, Fragment, renderList, mergeProps } from 'vue';
import { ChevronDownIcon } from '@heroicons/vue/outline';

var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};

const props = {
  duration: {
    type: [Number, Object],
    default: 300,
  },
  transition: {
    type: String,
    default: 'ease-in-out',
  },
  show: Boolean,
  navbar: Boolean,
};

const _sfc_main$2 = {
  name: 'VCollapse',
  props,
  emits: ['finish'],
  data() {
    return {
      collapsing: false,
      heightWatcher: null,
      visible: this.show,
      el: null,
    };
  },
  computed: {
    toggleTime() {
      return (
        (this.visible ? this.duration.show : this.duration.hide) ||
        this.duration
      );
    },
  },
  watch: {
    show(val) {
      this.visible = val;
    },
    visible(val) {
      if (this.toggleTime) {
        this.collapseController(val);
      } else {
        this.reset();
      }
    },
  },
  mounted() {
    this.$el.style.display = this.visible ? '' : 'none';
  },
  beforeUnmount() {
    clearTimeout(this.heightWatcher);
  },
  methods: {
    collapseController(val) {
      if (this.collapsing === false) {
        val ? this.toggle(true) : this.toggle(false);
        this.setFinishTimer(this.toggleTime);
      } else {
        this.setTransition();
        this.turn();
        const height = Number(this.collapsing.slice(0, -2));
        const current = this.$el.offsetHeight;
        const time = (val ? height - current : current) / height;
        this.setFinishTimer(this.toggleTime * time);
      }
    },
    turn() {
      if (this.visible) {
        this.$el.style.height = this.collapsing;
      } else {
        this.$el.style.height = 0;
      }
    },
    toggle(val) {
      this.$el.style.display = '';
      this.collapsing = this.$el.scrollHeight + 'px';
      this.$el.style.height = val ? 0 : this.$el.scrollHeight + 'px';
      this.$el.style.overflow = 'hidden';
      this.setTransition();
      const self = this;
      setTimeout(() => {
        self.$el.style.height = val ? this.collapsing : 0;
      }, 0);
    },
    setTransition() {
      this.$el.style.transition = `all ${this.toggleTime}ms ${this.transition}`;
    },
    setFinishTimer(duration) {
      clearTimeout(this.heightWatcher);
      this.heightWatcher = setTimeout(() => this.reset(), duration);
    },
    reset() {
      this.collapsing = false;
      this.$el.style.display = this.visible ? '' : 'none';
      this.$el.style.height = '';
      this.$el.style.overflow = '';
      this.$el.style.transition = '';
      this.$emit('finish', this.visible);
    },
  },
};

function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createElementBlock("div", {
    class: normalizeClass({'navbar-collapse': _ctx.navbar})
  }, [
    renderSlot(_ctx.$slots, "default", { open: $data.visible })
  ], 2))
}
var VCollapse = /*#__PURE__*/_export_sfc(_sfc_main$2, [['render',_sfc_render]]);

const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  props: {
    modelValue: {
      type: Boolean,
      default: false
    },
    defaultOpen: {
      type: Boolean,
      default: false
    },
    title: {
      type: String,
      default: ""
    },
    headerClass: {
      type: String,
      default: "font-semibold"
    },
    activeClass: {
      type: String,
      default: ""
    },
    wrapperClass: {
      type: String,
      default: "mb-5"
    },
    inactiveClass: {
      type: String,
      default: ""
    },
    activatorClass: {
      type: String,
      default: ""
    },
    panelClass: {
      type: String,
      default: "px-4 pb-4"
    },
    hideIcon: {
      type: Boolean,
      default: false
    }
  },
  emits: ["update:modelValue", "change"],
  setup(__props, { emit }) {
    const props = __props;
    const {
      modelValue,
      title,
      activeClass,
      inactiveClass,
      activatorClass,
      panelClass
    } = toRefs(props);
    const isOpen = ref(modelValue.value);
    const toggle = () => isOpen.value = !isOpen.value;
    watch(modelValue, (value) => {
      isOpen.value = value;
    }, { immediate: true });
    watch(isOpen, (value) => {
      emit("update:modelValue", value);
      emit("change", value);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createElementVNode("div", {
          class: normalizeClass(["py-3 w-full flex justify-between items-center px-4 gap-x-4 transition duration-300 group cursor-pointer font-semibold", [unref(activatorClass), isOpen.value ? unref(activeClass) : unref(inactiveClass)]]),
          onClick: toggle
        }, [
          renderSlot(_ctx.$slots, "header", { isOpen: isOpen.value }, () => [
            createTextVNode(toDisplayString(unref(title)), 1)
          ]),
          renderSlot(_ctx.$slots, "icon", {}, () => [
            !__props.hideIcon ? (openBlock(), createBlock(unref(ChevronDownIcon), {
              key: 0,
              class: normalizeClass(["w-5 h-5 transform transition duration-300", [isOpen.value ? "rotate-180" : ""]])
            }, null, 8, ["class"])) : createCommentVNode("", true)
          ])
        ], 2),
        createVNode(VCollapse, { show: isOpen.value }, {
          default: withCtx(() => [
            createElementVNode("div", {
              class: normalizeClass(unref(panelClass))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2)
          ]),
          _: 3
        }, 8, ["show"])
      ]);
    };
  }
});

const _hoisted_1 = { ref: "root" };
const _sfc_main = /* @__PURE__ */ defineComponent({
  props: {
    modelValue: { type: Boolean, default: false },
    accordion: { type: Boolean, default: false },
    items: { default: () => [] }
  },
  emits: [
    "update:modelValue",
    "update:items",
    "item:change",
    "onClickItems"
  ],
  setup(__props, { emit }) {
    const props = __props;
    const { accordion, items } = toRefs(props);
    const groupItems = ref(items.value);
    watch(items, (val) => {
      groupItems.value = val;
    }, { immediate: true });
    const onChange = (isOpen, item, idx) => {
      emit("item:change", { isOpen, item });
      if (accordion.value) {
        items.value.forEach((currentItem, key) => {
          if (key === idx) {
            currentItem.isOpen = isOpen;
          } else {
            currentItem.isOpen = false;
          }
        });
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1, [
        renderSlot(_ctx.$slots, "default", {}, () => [
          renderSlot(_ctx.$slots, "group:header"),
          (openBlock(true), createElementBlock(Fragment, null, renderList(groupItems.value, (item, idx) => {
            return openBlock(), createBlock(_sfc_main$1, mergeProps({
              modelValue: item.isOpen,
              "onUpdate:modelValue": ($event) => item.isOpen = $event
            }, item, {
              onChange: ($event) => onChange($event, item, idx)
            }), {
              header: withCtx(() => [
                renderSlot(_ctx.$slots, "item:header", {
                  item,
                  index: idx
                })
              ]),
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "items", {
                  row: item,
                  index: idx
                }, () => [
                  renderSlot(_ctx.$slots, `item.${idx}`, { item }, () => [
                    createTextVNode(toDisplayString(item.content), 1)
                  ])
                ])
              ]),
              _: 2
            }, 1040, ["modelValue", "onUpdate:modelValue", "onChange"]);
          }), 256))
        ])
      ], 512);
    };
  }
});

export { VCollapse, _sfc_main$1 as VCollapsible, _sfc_main as VCollapsibleGroup, _sfc_main$1 as default };
