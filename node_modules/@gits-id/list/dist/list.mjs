import { defineComponent as y, openBlock as c, createElementBlock as u, renderSlot as o, normalizeProps as w, guardReactiveProps as L, computed as h, resolveComponent as T, useAttrs as V, createBlock as P, resolveDynamicComponent as b, unref as d, mergeProps as A, withCtx as g, createElementVNode as C, normalizeClass as p, createVNode as $, createCommentVNode as k, toDisplayString as O, toRefs as D, ref as N, watch as I, Fragment as R } from "vue";
import { Icon as x } from "@iconify/vue";
import { VCollapse as z } from "@gits-id/collapsible";
const E = { class: "flex flex-col group overflow-hidden" }, Q = /* @__PURE__ */ y({
  __name: "List",
  props: {
    hidePrepend: { type: Boolean, default: !1 },
    hideAppend: { type: Boolean, default: !1 }
  },
  setup(e) {
    const t = e;
    return (n, r) => (c(), u("div", E, [
      o(n.$slots, "default", w(L(t)))
    ]));
  }
}), U = /* @__PURE__ */ y({
  __name: "ListItem",
  props: {
    to: null,
    href: null,
    as: null,
    defaultClass: { default: "select-none truncate whitespace-nowrap" },
    prependClass: { default: "w-auto shrink-0" },
    prependIcon: null,
    prependIconClass: null,
    appendClass: { default: "w-auto shrink-0" },
    appendIcon: null,
    appendIconClass: null,
    hidePrepend: { type: Boolean, default: !1 },
    hideAppend: { type: Boolean, default: !1 },
    hover: { type: Boolean },
    hoverClass: { default: "hover:bg-gray-100" },
    shaped: { type: Boolean, default: !1 },
    shapedClass: { default: "rounded-r-full" },
    rounded: { type: Boolean, default: !1 },
    hideText: { type: Boolean },
    appendText: null,
    appendTextClass: { default: "" },
    tile: { type: Boolean, default: !1 }
  },
  emits: ["click:prepend", "click:prependIcon", "click:append", "click:appendIcon", "click:appendText"],
  setup(e, { emit: t }) {
    const n = e, r = h(() => n.to ? T("RouterLink") : n.href ? "a" : n.as || "div"), s = V(), i = h(() => n.to ? { to: n.to } : n.href ? { href: n.href } : s), f = h(() => n.hover || n.to || n.href ? n.hoverClass : ""), m = h(() => n.rounded ? "rounded-full" : n.tile ? "rounded-none" : "rounded");
    return (l, a) => (c(), P(b(d(r)), A({
      class: ["flex gap-4 px-3 py-2 transition duration-300 items-center", [
        d(f),
        d(m),
        {
          [e.shapedClass]: e.shaped
        }
      ]]
    }, d(i)), {
      default: g(() => [
        e.hidePrepend ? k("", !0) : o(l.$slots, "prepend", { key: 0 }, () => [
          C("div", {
            class: p(e.prependClass),
            onClick: a[1] || (a[1] = (v) => t("click:prepend"))
          }, [
            o(l.$slots, "prepend.icon", {}, () => [
              $(d(x), {
                icon: e.prependIcon,
                class: p(["transition duration-300 transform w-5 h-5", e.prependIconClass]),
                onClick: a[0] || (a[0] = (v) => t("click:prependIcon"))
              }, null, 8, ["icon", "class"])
            ])
          ], 2)
        ]),
        e.hideText ? k("", !0) : (c(), u("div", {
          key: 1,
          class: p(["flex-1", e.defaultClass])
        }, [
          o(l.$slots, "default")
        ], 2)),
        e.hideAppend ? k("", !0) : o(l.$slots, "append", { key: 2 }, () => [
          C("div", {
            class: p(["flex gap-1 items-center", e.appendClass]),
            onClick: a[4] || (a[4] = (v) => t("click:append"))
          }, [
            o(l.$slots, "append.text", {}, () => [
              C("span", {
                class: p(e.appendTextClass),
                onClick: a[2] || (a[2] = (v) => t("click:appendText"))
              }, O(e.appendText), 3)
            ]),
            o(l.$slots, "append.icon", {}, () => [
              $(d(x), {
                icon: e.appendIcon,
                class: p(["transition duration-300 transform w-5 h-5", e.appendIconClass]),
                onClick: a[3] || (a[3] = (v) => t("click:appendIcon"))
              }, null, 8, ["icon", "class"])
            ])
          ], 2)
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), W = /* @__PURE__ */ y({
  __name: "ListCollapse",
  props: {
    modelValue: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, { modelValue: r } = D(n), s = N(r.value);
    I(r, (l) => s.value = l), I(s, (l) => t("update:modelValue", l));
    const i = () => s.value = !1, f = () => s.value = !0, m = () => s.value = !s.value;
    return (l, a) => (c(), u(R, null, [
      o(l.$slots, "activator", {
        isOpen: s.value,
        close: i,
        open: f,
        toggle: m
      }),
      $(d(z), { show: s.value }, {
        default: g(() => [
          o(l.$slots, "default", {
            isOpen: s.value,
            close: i,
            open: f,
            toggle: m
          })
        ]),
        _: 3
      }, 8, ["show"])
    ], 64));
  }
}), B = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [r, s] of t)
    n[r] = s;
  return n;
}, S = {}, F = { class: "border-b" };
function H(e, t) {
  return c(), u("div", F);
}
const X = /* @__PURE__ */ B(S, [["render", H]]), j = {}, q = { class: "text-gray-500 uppercase px-3 text-sm my-1" };
function G(e, t) {
  return c(), u("div", q, [
    o(e.$slots, "default")
  ]);
}
const Y = /* @__PURE__ */ B(j, [["render", G]]);
export {
  Q as List,
  W as ListCollapse,
  U as ListItem,
  X as ListItemDivider,
  Y as ListItemHeader,
  Q as default
};
